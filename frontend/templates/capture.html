<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Enterprise Measurement Agent ‚Äî Professional Body Measurement System</title>
  <style>
    :root {
      --primary-50: #f0f4ff;
      --primary-100: #e0e9ff;
      --primary-200: #c7d7fe;
      --primary-300: #a5bbfc;
      --primary-400: #8194f8;
      --primary-500: #6366f1;
      --primary-600: #4f46e5;
      --primary-700: #4338ca;
      --primary-800: #3730a3;
      --primary-900: #312e81;
      --gray-50: #f9fafb;
      --gray-100: #f3f4f6;
      --gray-200: #e5e7eb;
      --gray-300: #d1d5db;
      --gray-400: #9ca3af;
      --gray-500: #6b7280;
      --gray-600: #4b5563;
      --gray-700: #374151;
      --gray-800: #1f2937;
      --gray-900: #111827;
      --success-50: #ecfdf5;
      --success-500: #10b981;
      --success-600: #059669;
      --success-700: #047857;
      --error-50: #fef2f2;
      --error-500: #ef4444;
      --error-600: #dc2626;
      --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
      --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
      --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
      --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
    }
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
      background: linear-gradient(135deg, var(--gray-50) 0%, var(--primary-50) 100%);
      min-height: 100vh;
      padding: 24px;
      color: var(--gray-900);
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
      background: white;
      border-radius: 16px;
      box-shadow: var(--shadow-xl);
      overflow: hidden;
      border: 1px solid var(--gray-200);
    }
    header {
      background: linear-gradient(135deg, var(--primary-600) 0%, var(--primary-700) 100%);
      color: white;
      padding: 40px 32px;
      border-bottom: 4px solid var(--primary-800);
      position: relative;
      overflow: hidden;
    }
    header::before {
      content: '';
      position: absolute;
      top: 0;
      right: 0;
      width: 400px;
      height: 400px;
      background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
      pointer-events: none;
    }
    header .header-content {
      position: relative;
      z-index: 1;
      max-width: 800px;
    }
    header h1 {
      font-size: 32px;
      font-weight: 700;
      margin-bottom: 8px;
      letter-spacing: -0.5px;
    }
    header p {
      font-size: 16px;
      opacity: 0.95;
      font-weight: 400;
      letter-spacing: 0.2px;
    }
    .content {
      padding: 48px 32px;
    }
    .step {
      display: none;
    }
    .step.active {
      display: block;
      animation: fadeIn 0.4s ease-out;
    }
    @keyframes fadeIn {
      from { 
        opacity: 0;
        transform: translateY(8px);
      }
      to { 
        opacity: 1;
        transform: translateY(0);
      }
    }
    .step-title {
      font-size: 28px;
      color: var(--gray-900);
      margin-bottom: 24px;
      display: flex;
      align-items: center;
      font-weight: 700;
      letter-spacing: -0.5px;
    }
    .step-number {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 48px;
      height: 48px;
      background: linear-gradient(135deg, var(--primary-500) 0%, var(--primary-600) 100%);
      color: white;
      border-radius: 12px;
      text-align: center;
      margin-right: 16px;
      font-weight: 700;
      font-size: 20px;
      box-shadow: var(--shadow-md);
    }
    .video-container {
      background: var(--gray-900);
      border-radius: 12px;
      overflow: hidden;
      margin: 24px 0;
      position: relative;
      box-shadow: var(--shadow-lg);
      border: 2px solid var(--gray-200);
    }
    video, canvas {
      width: 100%;
      height: auto;
      display: block;
    }
    .canvas-hidden {
      display: none;
    }
    .info-box {
      background: linear-gradient(135deg, var(--primary-50) 0%, var(--primary-100) 100%);
      border-left: 4px solid var(--primary-500);
      padding: 20px 24px;
      margin: 24px 0;
      border-radius: 8px;
      font-size: 15px;
      line-height: 1.7;
      color: var(--gray-800);
      box-shadow: var(--shadow-sm);
    }
    .info-box strong {
      color: var(--primary-700);
      font-weight: 600;
    }
    .input-group {
      margin: 24px 0;
    }
    label {
      display: block;
      margin-bottom: 10px;
      color: var(--gray-700);
      font-weight: 600;
      font-size: 14px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    input[type="text"],
    input[type="number"],
    input[type="email"],
    input[type="tel"] {
      width: 100%;
      padding: 14px 16px;
      border: 2px solid var(--gray-300);
      border-radius: 8px;
      font-size: 15px;
      transition: all 0.2s ease;
      background: white;
      color: var(--gray-900);
      font-family: inherit;
    }
    input:focus {
      outline: none;
      border-color: var(--primary-500);
      box-shadow: 0 0 0 4px var(--primary-100);
      background: white;
    }
    input::placeholder {
      color: var(--gray-400);
    }
    .button-group {
      display: flex;
      gap: 12px;
      margin: 32px 0;
      flex-wrap: wrap;
    }
    button {
      padding: 14px 28px;
      border: none;
      border-radius: 8px;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      flex: 1;
      min-width: 160px;
      font-family: inherit;
      letter-spacing: 0.3px;
      position: relative;
      overflow: hidden;
    }
    button::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.3);
      transform: translate(-50%, -50%);
      transition: width 0.6s, height 0.6s;
    }
    button:active::before {
      width: 300px;
      height: 300px;
    }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none !important;
    }
    .btn-primary {
      background: linear-gradient(135deg, var(--primary-500) 0%, var(--primary-600) 100%);
      color: white;
      box-shadow: var(--shadow-md);
    }
    .btn-primary:hover:not(:disabled) {
      background: linear-gradient(135deg, var(--primary-600) 0%, var(--primary-700) 100%);
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg);
    }
    .btn-secondary {
      background: var(--gray-100);
      color: var(--gray-700);
      border: 2px solid var(--gray-300);
    }
    .btn-secondary:hover:not(:disabled) {
      background: var(--gray-200);
      border-color: var(--gray-400);
    }
    .btn-success {
      background: linear-gradient(135deg, var(--success-500) 0%, var(--success-600) 100%);
      color: white;
      box-shadow: var(--shadow-md);
    }
    .btn-success:hover:not(:disabled) {
      background: linear-gradient(135deg, var(--success-600) 0%, var(--success-700) 100%);
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg);
    }
    .progress-bar {
      width: 100%;
      height: 6px;
      background: var(--gray-200);
      border-radius: 3px;
      margin: 0 0 32px 0;
      overflow: hidden;
      box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
    }
    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--primary-500) 0%, var(--primary-600) 100%);
      transition: width 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 0 10px rgba(99, 102, 241, 0.5);
    }
    .status-message {
      padding: 16px 20px;
      border-radius: 8px;
      margin: 0 0 24px 0;
      display: none;
      font-size: 14px;
      font-weight: 500;
      border: 2px solid;
      align-items: center;
      gap: 12px;
    }
    .status-message::before {
      content: '';
      display: inline-block;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      flex-shrink: 0;
    }
    .status-message.show {
      display: flex;
      animation: slideDown 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    @keyframes slideDown {
      from {
        opacity: 0;
        transform: translateY(-12px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    .status-success {
      background: var(--success-50);
      color: var(--success-700);
      border-color: var(--success-500);
    }
    .status-success::before {
      background: var(--success-500);
    }
    .status-error {
      background: var(--error-50);
      color: var(--error-600);
      border-color: var(--error-500);
    }
    .status-error::before {
      background: var(--error-500);
    }
    .status-info {
      background: var(--primary-50);
      color: var(--primary-700);
      border-color: var(--primary-500);
    }
    .status-info::before {
      background: var(--primary-500);
      animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    .measurements-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 16px;
      margin: 24px 0;
    }
    .measurement-card {
      background: linear-gradient(135deg, var(--gray-50) 0%, white 100%);
      padding: 20px;
      border-radius: 12px;
      border: 2px solid var(--gray-200);
      transition: all 0.3s ease;
      box-shadow: var(--shadow-sm);
    }
    .measurement-card:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-md);
      border-color: var(--primary-300);
    }
    .measurement-card h3 {
      font-size: 11px;
      color: var(--gray-500);
      text-transform: uppercase;
      margin-bottom: 12px;
      font-weight: 700;
      letter-spacing: 1px;
    }
    .measurement-card .value {
      font-size: 28px;
      font-weight: 700;
      color: var(--primary-600);
      letter-spacing: -0.5px;
    }
    .measurement-card .unit {
      font-size: 14px;
      color: var(--gray-500);
      margin-left: 4px;
      font-weight: 600;
    }
    .angle-indicator {
      display: inline-block;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      margin: 0 6px;
      transition: all 0.3s ease;
      border: 2px solid transparent;
    }
    .angle-indicator.captured {
      background: var(--success-500);
      box-shadow: 0 0 8px var(--success-500);
      border-color: var(--success-600);
    }
    .angle-indicator.pending {
      background: var(--gray-300);
      border-color: var(--gray-400);
    }
    @media (max-width: 768px) {
      body {
        padding: 16px;
      }
      .content {
        padding: 32px 20px;
      }
      header {
        padding: 32px 20px;
      }
      header h1 {
        font-size: 24px;
      }
      .step-title {
        font-size: 22px;
      }
      .button-group {
        flex-direction: column;
      }
      button {
        min-width: 100%;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <div class="header-content">
        <h1>‚ö° Enterprise Measurement Agent</h1>
        <p>Professional Body Measurement System for Enterprise Solutions</p>
      </div>
    </header>

    <div class="content">
      <!-- Progress Bar -->
      <div class="progress-bar">
        <div class="progress-fill" id="progressFill"></div>
      </div>

      <!-- Status Message -->
      <div class="status-message" id="statusMessage"></div>

      <!-- Step 1: Customer Info -->
      <div class="step active" id="step1">
        <div class="step-title">
          <div class="step-number">1</div>
          Customer Information
        </div>
        <div class="info-box">
          üìã Please provide customer details. This information will be securely stored with the measurement profile.
        </div>
        <div class="input-group">
          <label>Full Name *</label>
          <input type="text" id="customerName" placeholder="Enter customer's full name" required />
        </div>
        <div class="input-group">
          <label>Height (cm) *</label>
          <input type="number" id="customerHeight" placeholder="e.g., 170" min="100" max="250" required />
        </div>
        <div class="input-group">
          <label>Phone Number (Optional)</label>
          <input type="tel" id="customerPhone" placeholder="+1 (555) 000-0000" />
        </div>
        <div class="input-group">
          <label>Email Address (Optional)</label>
          <input type="email" id="customerEmail" placeholder="customer@example.com" />
        </div>
        <div class="button-group">
          <button class="btn-primary" onclick="nextStep(2)">Continue to Calibration ‚Üí</button>
        </div>
      </div>

      <!-- Step 2: Calibration -->
      <div class="step" id="step2">
        <div class="step-title">
          <div class="step-number">2</div>
          Camera Calibration
        </div>
        <div class="info-box">
          üéØ Position the customer <strong>1.5 meters away from the camera</strong> with full body visible. The system will calibrate using the provided height for accurate measurements.
        </div>
        <div class="video-container">
          <video id="videoCalibrate" autoplay playsinline></video>
        </div>
        <canvas id="canvasCalibrate" class="canvas-hidden"></canvas>
        <div class="button-group">
          <button class="btn-primary" onclick="captureCalibration()" id="calibrateBtn">Capture for Calibration</button>
          <button class="btn-secondary" onclick="prevStep(1)">‚Üê Back</button>
        </div>
      </div>

      <!-- Step 3: Front View -->
      <div class="step" id="step3">
        <div class="step-title">
          <div class="step-number">3</div>
          Front View Capture
          <span class="angle-indicator captured" id="indicator-front"></span>
        </div>
        <div class="info-box">
          üì∏ <strong>Face the camera directly</strong> with arms relaxed at sides. Maintain an upright posture for optimal measurement accuracy.
        </div>
        <div class="video-container">
          <video id="videoFront" autoplay playsinline></video>
        </div>
        <canvas id="canvasFront" class="canvas-hidden"></canvas>
        <div class="button-group">
          <button class="btn-primary" onclick="captureFrontView()" id="frontBtn">Capture Front View</button>
          <button class="btn-secondary" onclick="prevStep(2)">‚Üê Back</button>
        </div>
      </div>

      <!-- Step 4: Side View -->
      <div class="step" id="step4">
        <div class="step-title">
          <div class="step-number">4</div>
          Side Profile Capture
          <span class="angle-indicator" id="indicator-side"></span>
        </div>
        <div class="info-box">
          üì∏ <strong>Turn 90¬∞ to the left</strong> to show side profile. Keep arms at sides and maintain posture alignment.
        </div>
        <div class="video-container">
          <video id="videoSide" autoplay playsinline></video>
        </div>
        <canvas id="canvasSide" class="canvas-hidden"></canvas>
        <div class="button-group">
          <button class="btn-primary" onclick="captureSideView()" id="sideBtn">Capture Side View</button>
          <button class="btn-secondary" onclick="prevStep(3)">‚Üê Back</button>
        </div>
      </div>

      <!-- Step 5: Back View -->
      <div class="step" id="step5">
        <div class="step-title">
          <div class="step-number">5</div>
          Back View Capture
          <span class="angle-indicator" id="indicator-back"></span>
        </div>
        <div class="info-box">
          üì∏ <strong>Turn completely around (180¬∞ from front)</strong> showing the back. Keep shoulders level and posture straight.
        </div>
        <div class="video-container">
          <video id="videoBack" autoplay playsinline></video>
        </div>
        <canvas id="canvasBack" class="canvas-hidden"></canvas>
        <div class="button-group">
          <button class="btn-primary" onclick="captureBackView()" id="backBtn">Capture Back View</button>
          <button class="btn-secondary" onclick="prevStep(4)">‚Üê Back</button>
        </div>
      </div>

      <!-- Step 6: Review Measurements -->
      <div class="step" id="step6">
        <div class="step-title">
          <div class="step-number">6</div>
          Measurement Results
        </div>
        <div class="info-box">
          ‚úÖ Measurements successfully extracted from all capture angles. All values are displayed in centimeters.
        </div>
        <div class="measurements-grid" id="measurementsGrid"></div>
        <div class="button-group">
          <button class="btn-success" onclick="saveMeasurements()">‚úì Save Measurement Profile</button>
          <button class="btn-secondary" onclick="restartFlow()">Start Over</button>
        </div>
      </div>

      <!-- Step 7: Confirmation -->
      <div class="step" id="step7">
        <div class="step-title">
          <div class="step-number">7</div>
          Profile Saved Successfully
        </div>
        <div class="info-box" style="background: linear-gradient(135deg, var(--success-50) 0%, #ecfdf5 100%); border-color: var(--success-500);">
          ‚úÖ Measurement profile has been successfully saved to the system!
        </div>
        <div id="confirmationInfo" style="margin: 24px 0; padding: 24px; background: var(--gray-50); border-radius: 12px; border: 2px solid var(--gray-200); line-height: 1.8; font-size: 15px;"></div>
        <div class="button-group">
          <button class="btn-primary" onclick="restartFlow()">Start New Measurement</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    let currentStep = 1;
    let sessionId = null;
    let calibrationData = null;
    let measurements = null;
    let currentStream = null;

    // Use current origin if running on same server
    const API_BASE = "{{ backend_url }}";

    // Stop any active camera streams
    function stopCamera() {
      if (currentStream) {
        currentStream.getTracks().forEach(track => track.stop());
        currentStream = null;
      }
    }

    // Initialize cameras
    async function initCamera(videoElementId) {
      try {
        // Stop any existing stream first
        stopCamera();

        // Check if mediaDevices is available
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
          showStatus('Camera API not available. Please use HTTPS or localhost.', 'error');
          console.error('MediaDevices API not supported');
          return null;
        }

        const video = document.getElementById(videoElementId);
        if (!video) {
          showStatus('Video element not found', 'error');
          return null;
        }

        showStatus('Requesting camera access...', 'info');
        
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { 
            facingMode: 'user', 
            width: { ideal: 1280 }, 
            height: { ideal: 720 } 
          }
        });
        
        video.srcObject = stream;
        currentStream = stream;
        
        // Wait for video to be ready and play
        await new Promise((resolve, reject) => {
          video.onloadedmetadata = () => {
            video.play()
              .then(resolve)
              .catch(reject);
          };
          // Timeout after 10 seconds
          setTimeout(() => reject(new Error('Video load timeout')), 10000);
        });

        showStatus('Camera ready', 'success');
        return video;
      } catch (error) {
        let errorMsg = 'Camera access failed: ';
        
        if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
          errorMsg += 'Permission denied. Please allow camera access.';
        } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
          errorMsg += 'No camera found. Please connect a camera.';
        } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {
          errorMsg += 'Camera is already in use by another application.';
        } else if (error.name === 'OverconstrainedError') {
          errorMsg += 'Camera does not support requested settings.';
        } else if (error.name === 'SecurityError') {
          errorMsg += 'Security error. Please use HTTPS.';
        } else {
          errorMsg += error.message || 'Unknown error';
        }
        
        showStatus(errorMsg, 'error');
        console.error('Camera error:', error);
        return null;
      }
    }

    function showStatus(message, type = 'info') {
      const statusMsg = document.getElementById('statusMessage');
      statusMsg.textContent = message;
      statusMsg.className = `status-message show status-${type}`;
      setTimeout(() => statusMsg.classList.remove('show'), 5000);
    }

    function updateProgress(step) {
      const total = 7;
      const percent = (step / total) * 100;
      document.getElementById('progressFill').style.width = percent + '%';
    }

    function showStep(step) {
      // Stop camera when switching steps
      stopCamera();
      
      document.querySelectorAll('.step').forEach(el => el.classList.remove('active'));
      document.getElementById(`step${step}`).classList.add('active');
      updateProgress(step);
      window.scrollTo({ top: 0, behavior: 'smooth' });
      
      // Auto-initialize camera for video steps
      setTimeout(() => {
        if (step === 2) {
          initCamera('videoCalibrate');
        } else if (step === 3) {
          initCamera('videoFront');
        } else if (step === 4) {
          initCamera('videoSide');
        } else if (step === 5) {
          initCamera('videoBack');
        }
      }, 300);
    }

    function nextStep(step) {
      currentStep = step;
      showStep(step);
    }

    function prevStep(step) {
      currentStep = step;
      showStep(step);
    }

    async function captureCalibration() {
      try {
        showStatus('Initializing camera...', 'info');
        const video = await initCamera('videoCalibrate');
        
        if (!video) {
          showStatus('Failed to initialize camera', 'error');
          return;
        }

        // Wait for video to be ready
        await new Promise(resolve => {
          if (video.readyState === 4) resolve();
          else video.onloadedmetadata = resolve;
        });

        const canvas = document.getElementById('canvasCalibrate');
        const ctx = canvas.getContext('2d');
        canvas.width = video.videoWidth || 1280;
        canvas.height = video.videoHeight || 720;
        ctx.drawImage(video, 0, 0);

        showStatus('Capturing image...', 'info');

        // Convert canvas to blob using Promise
        const blob = await new Promise((resolve, reject) => {
          canvas.toBlob((blob) => {
            if (blob) {
              resolve(blob);
            } else {
              reject(new Error('Failed to create blob from canvas'));
            }
          }, 'image/jpeg', 0.9);
        });

        const formData = new FormData();
        formData.append('image', blob, 'calibration.jpg');
        const height = parseFloat(document.getElementById('customerHeight').value);
        
        if (!height || height < 100 || height > 250) {
          showStatus('Please enter a valid height (100-250 cm)', 'error');
          return;
        }

        formData.append('known_height_cm', height);

        try {
          showStatus('Sending to server...', 'info');
          const response = await fetch(`${API_BASE}/calibrate/setup`, {
            method: 'POST',
            body: formData
          });

          console.log('Response status:', response.status);
          const data = await response.json();
          console.log('Response data:', data);

          if (response.ok && data.status === 'ok') {
            sessionId = data.session_id;
            calibrationData = data.calibration;
            showStatus('‚úì Calibration successful! cm_per_pixel: ' + data.calibration.cm_per_pixel.toFixed(4), 'success');
            console.log('Moving to step 3...');
            setTimeout(() => {
              nextStep(3);
            }, 1500);
          } else {
            showStatus('Calibration failed: ' + (data.detail || data.message || 'Unknown error'), 'error');
          }
        } catch (error) {
          console.error('Fetch error:', error);
          showStatus('Network error: ' + error.message, 'error');
        }
      } catch (error) {
        console.error('Calibration error:', error);
        showStatus('Error: ' + error.message, 'error');
      }
    }

    async function captureAngle(videoId, canvasId, angleType) {
      if (!sessionId) {
        showStatus('No calibration. Run calibration first.', 'error');
        return;
      }

      try {
        showStatus(`Capturing ${angleType} view...`, 'info');
        const video = await initCamera(videoId);
        
        if (!video) {
          showStatus('Failed to initialize camera', 'error');
          return;
        }

        // Wait for video to be ready
        await new Promise(resolve => {
          if (video.readyState === 4) resolve();
          else video.onloadedmetadata = resolve;
        });

        const canvas = document.getElementById(canvasId);
        const ctx = canvas.getContext('2d');
        canvas.width = video.videoWidth || 1280;
        canvas.height = video.videoHeight || 720;
        ctx.drawImage(video, 0, 0);

        // Convert canvas to blob using Promise
        const blob = await new Promise((resolve, reject) => {
          canvas.toBlob((blob) => {
            if (blob) {
              resolve(blob);
            } else {
              reject(new Error('Failed to create blob from canvas'));
            }
          }, 'image/jpeg', 0.9);
        });

        const formData = new FormData();
        formData.append('image', blob, `${angleType}.jpg`);
        formData.append('session_id', sessionId);
        formData.append('angle_type', angleType);

        try {
          const response = await fetch(`${API_BASE}/capture/angle`, {
            method: 'POST',
            body: formData
          });

          console.log(`${angleType} - Response status:`, response.status);
          const data = await response.json();
          console.log(`${angleType} - Response data:`, data);

          if (response.ok && data.status === 'ok') {
            document.getElementById(`indicator-${angleType}`).classList.add('captured');
            showStatus(`‚úì ${angleType} view captured successfully!`, 'success');
            
            // Move to next step
            const nextStepNum = { 'front': 4, 'side': 5, 'back': 6 }[angleType];
            setTimeout(() => {
              if (nextStepNum === 6) {
                // Measurement extraction after back view
                extractMeasurements();
              } else {
                nextStep(nextStepNum);
              }
            }, 1500);
          } else {
            showStatus('Capture failed: ' + (data.detail || data.message || 'Unknown error'), 'error');
          }
        } catch (error) {
          console.error(`${angleType} fetch error:`, error);
          showStatus('Network error: ' + error.message, 'error');
        }
      } catch (error) {
        console.error(`${angleType} capture error:`, error);
        showStatus('Error: ' + error.message, 'error');
      }
    }

    function captureFrontView() {
      captureAngle('videoFront', 'canvasFront', 'front');
    }

    function captureSideView() {
      captureAngle('videoSide', 'canvasSide', 'side');
    }

    function captureBackView() {
      captureAngle('videoBack', 'canvasBack', 'back');
    }

    async function extractMeasurements() {
      if (!sessionId) {
        showStatus('No session. Please restart.', 'error');
        return;
      }

      try {
        showStatus('Extracting measurements...', 'info');
        const response = await fetch(`${API_BASE}/measure/extract?session_id=${sessionId}`, {
          method: 'POST'
        });

        console.log('Extract - Response status:', response.status);
        const data = await response.json();
        console.log('Extract - Response data:', data);

        if (response.ok && data.status === 'ok') {
          measurements = data.measurements;
          displayMeasurements();
          nextStep(6);
          showStatus('‚úì Measurements extracted successfully!', 'success');
        } else {
          showStatus('Extraction failed: ' + (data.detail || data.message || 'Unknown error'), 'error');
        }
      } catch (error) {
        console.error('Extract error:', error);
        showStatus('Error: ' + error.message, 'error');
      }
    }

    function displayMeasurements() {
      const grid = document.getElementById('measurementsGrid');
      grid.innerHTML = '';

      const meas = measurements;
      const allMeasurements = [
        ...Object.entries(meas.upper_body || {}),
        ...Object.entries(meas.torso || {}),
        ...Object.entries(meas.lower_body || {}),
        ...Object.entries(meas.full_body || {})
      ];

      allMeasurements.forEach(([key, value]) => {
        if (typeof value === 'number' && !key.includes('_px') && !key.includes('_confidence')) {
          const name = key.replace(/_/g, ' ').replace(/cm/g, '').trim();
          const card = document.createElement('div');
          card.className = 'measurement-card';
          card.innerHTML = `
            <h3>${name}</h3>
            <div><span class="value">${value.toFixed(1)}</span><span class="unit">cm</span></div>
          `;
          grid.appendChild(card);
        }
      });
    }

    async function saveMeasurements() {
      const customerInfo = {
        name: document.getElementById('customerName').value,
        phone: document.getElementById('customerPhone').value,
        email: document.getElementById('customerEmail').value
      };

      try {
        const response = await fetch(`${API_BASE}/customer/save`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            session_id: sessionId,
            customer_info: customerInfo,
            measurements: measurements
          })
        });
        const data = await response.json();

        if (data.status === 'ok') {
          document.getElementById('confirmationInfo').innerHTML = `
            <strong>Customer ID:</strong> ${data.customer_id}<br>
            <strong>File Saved:</strong> ${data.file_saved}<br>
            <strong>Measurements Count:</strong> ${data.measurements_count}
          `;
          nextStep(7);
          showStatus('‚úì Measurements saved successfully!', 'success');
        } else {
          showStatus('Save failed: ' + (data.detail || 'Unknown error'), 'error');
        }
      } catch (error) {
        showStatus('Error: ' + error.message, 'error');
      }
    }

    function restartFlow() {
      stopCamera();
      sessionId = null;
      calibrationData = null;
      measurements = null;
      document.getElementById('customerName').value = '';
      document.getElementById('customerPhone').value = '';
      document.getElementById('customerEmail').value = '';
      document.getElementById('customerHeight').value = '170';
      document.querySelectorAll('.angle-indicator').forEach(el => el.classList.remove('captured'));
      nextStep(1);
    }

    // Initialize on load
    window.addEventListener('load', () => {
      showStep(1);
      
      // Check for HTTPS or localhost
      if (location.protocol !== 'https:' && location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
        showStatus('‚ö†Ô∏è Camera requires HTTPS or localhost. Current: ' + location.protocol + '//' + location.hostname, 'error');
      }
    });

    // Clean up on page unload
    window.addEventListener('beforeunload', () => {
      stopCamera();
    });
  </script>
</body>
</html>
